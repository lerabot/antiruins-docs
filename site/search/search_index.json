{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to ANTIRUINS Engine # Easy to use, pre-compiled 2D game engine for the SEGA Dreamcast and PC. ANTIRUINS engine was initally developped for Fragmented Almanac, a SEGA Dreamcast game released in 2024. The engine is now free to use, for personal and commercial project, with source corde available on demand. Features: # Lua programming language. Loads .png and .dtex files with palette support. 2D engine with spritesheet support. Sound effect using .wav file. Audio streaming using CDDA and .wav files. Tiled map support. Basic collision system. VMU save + load, VMU bitmap display.","title":"Home"},{"location":"#welcome-to-antiruins-engine","text":"Easy to use, pre-compiled 2D game engine for the SEGA Dreamcast and PC. ANTIRUINS engine was initally developped for Fragmented Almanac, a SEGA Dreamcast game released in 2024. The engine is now free to use, for personal and commercial project, with source corde available on demand.","title":"Welcome to ANTIRUINS Engine"},{"location":"#features","text":"Lua programming language. Loads .png and .dtex files with palette support. 2D engine with spritesheet support. Sound effect using .wav file. Audio streaming using CDDA and .wav files. Tiled map support. Basic collision system. VMU save + load, VMU bitmap display.","title":"Features:"},{"location":"audio/","text":"\ud83d\udd0a AUDIO # audio types lua audio.SFX -- Used for short sound sample, one shots, etc. The sound is loaded directly in memory. Must be a .wav files under 65k samples. audio.WAV -- Used for audio streaming. Must be a .wav file. audio.CDDA -- Used for CDDA audio streaming. Filename will be the track number (0-99) and the file must be placed in the audio directory at the root of the engine. source lua local source = { loaded = false, id = 0, channel = -1, volume = 220, --0, 254 isPlaying = false, type = audio.SFX, } audio.load(filename, type) Loads a .wav (audio.SFX or audio.WAV) file. Returns a source. Type must be audio.SFX, audio.WAV or audio.CDDA audio.play(source, volume, loop ) Plays a source at 0-255 volume. audio.setVolume(source, volume) Sets the volume of a playing source . audio.free(source) Frees the memory of a loaded source . audio.isPlaying(source) audio.pause(source) audio.stop(source) audio.setPan(source, pan) Sets pan. 128 is center, 0 is full left, 255 is full right. Only works on .SFX type sound.","title":"Audio"},{"location":"audio/#audio","text":"audio types lua audio.SFX -- Used for short sound sample, one shots, etc. The sound is loaded directly in memory. Must be a .wav files under 65k samples. audio.WAV -- Used for audio streaming. Must be a .wav file. audio.CDDA -- Used for CDDA audio streaming. Filename will be the track number (0-99) and the file must be placed in the audio directory at the root of the engine. source lua local source = { loaded = false, id = 0, channel = -1, volume = 220, --0, 254 isPlaying = false, type = audio.SFX, } audio.load(filename, type) Loads a .wav (audio.SFX or audio.WAV) file. Returns a source. Type must be audio.SFX, audio.WAV or audio.CDDA audio.play(source, volume, loop ) Plays a source at 0-255 volume. audio.setVolume(source, volume) Sets the volume of a playing source . audio.free(source) Frees the memory of a loaded source . audio.isPlaying(source) audio.pause(source) audio.stop(source) audio.setPan(source, pan) Sets pan. 128 is center, 0 is full left, 255 is full right. Only works on .SFX type sound.","title":"\ud83d\udd0a AUDIO"},{"location":"config/","text":"CONFIGURE # ```lua -- config.lua holds some configuration for the engine -- the most important is which game to load by default. local config = { games = { {dir=\"game_example\", name=\"Example\"}, {dir=\"game_tower\", name=\"Tower\"}, }, -- Default game to load defaultGame = \"Example\", -- console output - disable this is you get slowdowns using BBA or Serial. contole = true, -- Path for lackages, libraries. The require function. -- Don't forget to add a semicolom at the end. ' ; ' reqPath = \"lua/?.lua;\" .. \"lua/lib/?.lua;\", } return config","title":"Config"},{"location":"config/#configure","text":"```lua -- config.lua holds some configuration for the engine -- the most important is which game to load by default. local config = { games = { {dir=\"game_example\", name=\"Example\"}, {dir=\"game_tower\", name=\"Tower\"}, }, -- Default game to load defaultGame = \"Example\", -- console output - disable this is you get slowdowns using BBA or Serial. contole = true, -- Path for lackages, libraries. The require function. -- Don't forget to add a semicolom at the end. ' ; ' reqPath = \"lua/?.lua;\" .. \"lua/lib/?.lua;\", } return config","title":"CONFIGURE"},{"location":"graphics/","text":"\ud83d\udd8c\ufe0f GRAPHICS # ANTIRUINS uses centered coordinate for drawing. This makes sprite rotation simpler to handle. Texture # The PVR only supports pow2 sized texture (8, 16, 32, 64, 128, 256, 512, 1024px). You can load .png files, but they takes some time to decompress, a much better alternative are .dtex file generated by pvrtex and texconv. local TEXTURE = { texture = id, -- texture ID used by the C engine filename = \"\", w, h = 0, 0, palette = { -- if you use paletted texture. index = 0, size = 0, colors = {} } } Font # The fonts are loaded as a bitmap font atlas, starting at character 32 (space). graphics.loadFont expect a column and row integer. For this example, there are 16 rows and 8 columns in this 512x256 textures. There is a Processing sketch included in the tool folder that can help you generate a font atlas. There are also some other fonts in the default folder. local FONT = { texture = 0, -- texture ID used by the engine charW = 0, -- char width size = 16, type = \"font\", } Palette # local PALETTE = { size = 16, --16(4BPP) or 256(8BPP) palette size index = 0, --the location of the palette (between 1 and 1024), 0 is no palette. colors = {}, --table of {r,g,b,a} values (between 0.0 and 1.0) } graphics.loadTexture(filename) Loads a pow2 .png or .dtex image. Returns a texture. graphics.freeTexture(texture) Frees the texture data. graphics.drawTexture(texture, x, y, *scaleX, scaleY, angle, uv*) Draws a texture at x-y position. scaleX/ycaleY are floats. UV is a table with 4 x 0.0 - 1.0 uv coordinate. graphics.setDrawColor(r,g,b,a) Set the color (0.0 - 1.0) of future texture, shape, text. graphics.setClearColor(r,g,b,a) Set the color (0.0 - 1.0) of the background. graphics.loadFont(filename, col, row, *fontSize*) Loads a pow2 .png or .dtex image. Returns a font. Read the font documentation graphics.print(text, x, y, *center*) Prints text at x-y position. If center is true, the text is centered. graphics.setFontSize(fontSize) Sets the font size. graphics.drawRect(x, y, w, h, *mode*) Draws a rectangle. If mode is \u201ccorners\u201d , x and y becomes top-left coordinates. graphics.drawLine(x1, y1, x2, y2, width) Draws a line from (x1, y1) to (x2, y2) with the specified width. graphics.playVideo(videoFile, x, y, w, h) Plays a video file at the specified position and size. graphics.loadPalette(file) Returns a palette from a .dtex.pal file. graphics.setPalette(texture, palette) Replaces a texture palette with the provided palette . graphics.setPaletteColor(palette, colorNum, r,g,b,a) Set a single color in a specified palette. The \u2018r\u2019 argument can be a {r,g,b,a} table.","title":"Graphics"},{"location":"graphics/#graphics","text":"ANTIRUINS uses centered coordinate for drawing. This makes sprite rotation simpler to handle.","title":"\ud83d\udd8c\ufe0f GRAPHICS"},{"location":"graphics/#texture","text":"The PVR only supports pow2 sized texture (8, 16, 32, 64, 128, 256, 512, 1024px). You can load .png files, but they takes some time to decompress, a much better alternative are .dtex file generated by pvrtex and texconv. local TEXTURE = { texture = id, -- texture ID used by the C engine filename = \"\", w, h = 0, 0, palette = { -- if you use paletted texture. index = 0, size = 0, colors = {} } }","title":"Texture"},{"location":"graphics/#font","text":"The fonts are loaded as a bitmap font atlas, starting at character 32 (space). graphics.loadFont expect a column and row integer. For this example, there are 16 rows and 8 columns in this 512x256 textures. There is a Processing sketch included in the tool folder that can help you generate a font atlas. There are also some other fonts in the default folder. local FONT = { texture = 0, -- texture ID used by the engine charW = 0, -- char width size = 16, type = \"font\", }","title":"Font"},{"location":"graphics/#palette","text":"local PALETTE = { size = 16, --16(4BPP) or 256(8BPP) palette size index = 0, --the location of the palette (between 1 and 1024), 0 is no palette. colors = {}, --table of {r,g,b,a} values (between 0.0 and 1.0) } graphics.loadTexture(filename) Loads a pow2 .png or .dtex image. Returns a texture. graphics.freeTexture(texture) Frees the texture data. graphics.drawTexture(texture, x, y, *scaleX, scaleY, angle, uv*) Draws a texture at x-y position. scaleX/ycaleY are floats. UV is a table with 4 x 0.0 - 1.0 uv coordinate. graphics.setDrawColor(r,g,b,a) Set the color (0.0 - 1.0) of future texture, shape, text. graphics.setClearColor(r,g,b,a) Set the color (0.0 - 1.0) of the background. graphics.loadFont(filename, col, row, *fontSize*) Loads a pow2 .png or .dtex image. Returns a font. Read the font documentation graphics.print(text, x, y, *center*) Prints text at x-y position. If center is true, the text is centered. graphics.setFontSize(fontSize) Sets the font size. graphics.drawRect(x, y, w, h, *mode*) Draws a rectangle. If mode is \u201ccorners\u201d , x and y becomes top-left coordinates. graphics.drawLine(x1, y1, x2, y2, width) Draws a line from (x1, y1) to (x2, y2) with the specified width. graphics.playVideo(videoFile, x, y, w, h) Plays a video file at the specified position and size. graphics.loadPalette(file) Returns a palette from a .dtex.pal file. graphics.setPalette(texture, palette) Replaces a texture palette with the provided palette . graphics.setPaletteColor(palette, colorNum, r,g,b,a) Set a single color in a specified palette. The \u2018r\u2019 argument can be a {r,g,b,a} table.","title":"Palette"},{"location":"input/","text":"\ud83c\udfae INPUT # Button names # local buttons = {\"A\", \"B\", \"X\", \"Y\", \"UP\", \"DOWN\", \"LEFT\", \"RIGHT\", \"START\"} input.getButton(button, controllerNumber) Returns true/false if button has been pressed. input.getButtonDown(button, *controllerNumber*) Returns true/false if button is being held. input.getJoystick(*controllerNumber*) Returns the joystick position as a vector. input.getTriggers(*controllerNumber*) Returns both triggers as a vector.","title":"Input"},{"location":"input/#input","text":"","title":"\ud83c\udfae INPUT"},{"location":"input/#button-names","text":"local buttons = {\"A\", \"B\", \"X\", \"Y\", \"UP\", \"DOWN\", \"LEFT\", \"RIGHT\", \"START\"} input.getButton(button, controllerNumber) Returns true/false if button has been pressed. input.getButtonDown(button, *controllerNumber*) Returns true/false if button is being held. input.getJoystick(*controllerNumber*) Returns the joystick position as a vector. input.getTriggers(*controllerNumber*) Returns both triggers as a vector.","title":"Button names"},{"location":"install/","text":"INSTALL # Download the engine from itch.io and decompress it somewhere on your computer. Run make dependency to install mkdcdisc, lxdream-nitro, love2d, dc-tools and texconv. Make a new game using make new NAME=game_name . Don\u2019t forget to add the game to the config.lua file.","title":"Installation Guide"},{"location":"install/#install","text":"Download the engine from itch.io and decompress it somewhere on your computer. Run make dependency to install mkdcdisc, lxdream-nitro, love2d, dc-tools and texconv. Make a new game using make new NAME=game_name . Don\u2019t forget to add the game to the config.lua file.","title":"INSTALL"},{"location":"utilities/","text":"\ud83d\udee0\ufe0f UTILITIES # Functions Description findFile(filename) Returns a path if the filename is found on the /cd, /rd, /pc and or in the loaded game folder. getUS() Returns the current microseconds since game as started. getMS() Returns the current millisecond since game as started. getFPS() Returns the current frame per seconds. mountRomdisk(fileName, mountpoint) Mount a romdisk at specified mountpoint. The most common mountpoint is \u201c/rd\u201d unmountRomdisk(mountpoint) Unmount the specified mountpoint and frees up memory.","title":"Utilities"},{"location":"utilities/#utilities","text":"Functions Description findFile(filename) Returns a path if the filename is found on the /cd, /rd, /pc and or in the loaded game folder. getUS() Returns the current microseconds since game as started. getMS() Returns the current millisecond since game as started. getFPS() Returns the current frame per seconds. mountRomdisk(fileName, mountpoint) Mount a romdisk at specified mountpoint. The most common mountpoint is \u201c/rd\u201d unmountRomdisk(mountpoint) Unmount the specified mountpoint and frees up memory.","title":"\ud83d\udee0\ufe0f UTILITIES"},{"location":"vmu/","text":"\ud83d\udcbe VMU # save ```lua Keep these in mind when you create a new savefile: gameName - 16 character long. saveName - 26 character long. descShort - 16 character long. descLong - 32 character long. saveID - from 1 to 3. You should be able to save just about any Lua table on the VMU. ``` vmu animation ```lua -- To display images on the VMU, you need to create \u201canimations\u201d. -- These animations can be 1 frame long (static). -- To load multiple frames, they need a number suffix (frame1.bin, frame2.bin, frame3.bin, etc) local animatation = { icon = {}, -- image data cFrame = 1, -- current frame displayed length = frameNum or 1, speed = speed or 1, priority = priority or 1, active = false, filename = filename, } ``` vmu.checkForVMU() Check if there is a valid VMU present. vmu.initSavefile(gameName, saveName, descLong, descShort, saveID) Read the save notes. vmu.checkForSave(saveID) Check if a save file exists with the gameName and saveName specified in the saveID. vmu.saveGame(saveID, data) Save the data table in specified saveID. data can be any valid Lua Table. vmu.loadGame(saveID) Returns a data table from vmu.deleteGame(saveID) vmu.createAnimation(filename, frameNum, speed, priority) Returns an animation . Read the vmu animation notes . vmu.setScreen(animation, frame) Displays the frame (integer) of specified animation . vmu.playAnimation(animation, repeats, clearAfter) Displays an animation for repeat number of time. If clearAfter is true, the VMU image will be cleared once the animation is done. vmu.clearScreen() Clears the VMU screen. vmu.freeAnimation(animation) Frees the memory of the animation.","title":"VMU"},{"location":"vmu/#vmu","text":"save ```lua Keep these in mind when you create a new savefile: gameName - 16 character long. saveName - 26 character long. descShort - 16 character long. descLong - 32 character long. saveID - from 1 to 3. You should be able to save just about any Lua table on the VMU. ``` vmu animation ```lua -- To display images on the VMU, you need to create \u201canimations\u201d. -- These animations can be 1 frame long (static). -- To load multiple frames, they need a number suffix (frame1.bin, frame2.bin, frame3.bin, etc) local animatation = { icon = {}, -- image data cFrame = 1, -- current frame displayed length = frameNum or 1, speed = speed or 1, priority = priority or 1, active = false, filename = filename, } ``` vmu.checkForVMU() Check if there is a valid VMU present. vmu.initSavefile(gameName, saveName, descLong, descShort, saveID) Read the save notes. vmu.checkForSave(saveID) Check if a save file exists with the gameName and saveName specified in the saveID. vmu.saveGame(saveID, data) Save the data table in specified saveID. data can be any valid Lua Table. vmu.loadGame(saveID) Returns a data table from vmu.deleteGame(saveID) vmu.createAnimation(filename, frameNum, speed, priority) Returns an animation . Read the vmu animation notes . vmu.setScreen(animation, frame) Displays the frame (integer) of specified animation . vmu.playAnimation(animation, repeats, clearAfter) Displays an animation for repeat number of time. If clearAfter is true, the VMU image will be cleared once the animation is done. vmu.clearScreen() Clears the VMU screen. vmu.freeAnimation(animation) Frees the memory of the animation.","title":"\ud83d\udcbe VMU"}]}